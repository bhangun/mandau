// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: api/v1/service.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	NginxService_CreateVirtualHost_FullMethodName  = "/mandau.services.v1.NginxService/CreateVirtualHost"
	NginxService_EnableVirtualHost_FullMethodName  = "/mandau.services.v1.NginxService/EnableVirtualHost"
	NginxService_DisableVirtualHost_FullMethodName = "/mandau.services.v1.NginxService/DisableVirtualHost"
	NginxService_DeleteVirtualHost_FullMethodName  = "/mandau.services.v1.NginxService/DeleteVirtualHost"
	NginxService_ListVirtualHosts_FullMethodName   = "/mandau.services.v1.NginxService/ListVirtualHosts"
	NginxService_CreateReverseProxy_FullMethodName = "/mandau.services.v1.NginxService/CreateReverseProxy"
	NginxService_CreateLoadBalancer_FullMethodName = "/mandau.services.v1.NginxService/CreateLoadBalancer"
)

// NginxServiceClient is the client API for NginxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Nginx Management Service
type NginxServiceClient interface {
	CreateVirtualHost(ctx context.Context, in *CreateVirtualHostRequest, opts ...grpc.CallOption) (*CreateVirtualHostResponse, error)
	EnableVirtualHost(ctx context.Context, in *EnableVirtualHostRequest, opts ...grpc.CallOption) (*EnableVirtualHostResponse, error)
	DisableVirtualHost(ctx context.Context, in *DisableVirtualHostRequest, opts ...grpc.CallOption) (*DisableVirtualHostResponse, error)
	DeleteVirtualHost(ctx context.Context, in *DeleteVirtualHostRequest, opts ...grpc.CallOption) (*DeleteVirtualHostResponse, error)
	ListVirtualHosts(ctx context.Context, in *ListVirtualHostsRequest, opts ...grpc.CallOption) (*ListVirtualHostsResponse, error)
	CreateReverseProxy(ctx context.Context, in *CreateReverseProxyRequest, opts ...grpc.CallOption) (*CreateReverseProxyResponse, error)
	CreateLoadBalancer(ctx context.Context, in *CreateLoadBalancerRequest, opts ...grpc.CallOption) (*CreateLoadBalancerResponse, error)
}

type nginxServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNginxServiceClient(cc grpc.ClientConnInterface) NginxServiceClient {
	return &nginxServiceClient{cc}
}

func (c *nginxServiceClient) CreateVirtualHost(ctx context.Context, in *CreateVirtualHostRequest, opts ...grpc.CallOption) (*CreateVirtualHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVirtualHostResponse)
	err := c.cc.Invoke(ctx, NginxService_CreateVirtualHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nginxServiceClient) EnableVirtualHost(ctx context.Context, in *EnableVirtualHostRequest, opts ...grpc.CallOption) (*EnableVirtualHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableVirtualHostResponse)
	err := c.cc.Invoke(ctx, NginxService_EnableVirtualHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nginxServiceClient) DisableVirtualHost(ctx context.Context, in *DisableVirtualHostRequest, opts ...grpc.CallOption) (*DisableVirtualHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableVirtualHostResponse)
	err := c.cc.Invoke(ctx, NginxService_DisableVirtualHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nginxServiceClient) DeleteVirtualHost(ctx context.Context, in *DeleteVirtualHostRequest, opts ...grpc.CallOption) (*DeleteVirtualHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteVirtualHostResponse)
	err := c.cc.Invoke(ctx, NginxService_DeleteVirtualHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nginxServiceClient) ListVirtualHosts(ctx context.Context, in *ListVirtualHostsRequest, opts ...grpc.CallOption) (*ListVirtualHostsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVirtualHostsResponse)
	err := c.cc.Invoke(ctx, NginxService_ListVirtualHosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nginxServiceClient) CreateReverseProxy(ctx context.Context, in *CreateReverseProxyRequest, opts ...grpc.CallOption) (*CreateReverseProxyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateReverseProxyResponse)
	err := c.cc.Invoke(ctx, NginxService_CreateReverseProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nginxServiceClient) CreateLoadBalancer(ctx context.Context, in *CreateLoadBalancerRequest, opts ...grpc.CallOption) (*CreateLoadBalancerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateLoadBalancerResponse)
	err := c.cc.Invoke(ctx, NginxService_CreateLoadBalancer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NginxServiceServer is the server API for NginxService service.
// All implementations must embed UnimplementedNginxServiceServer
// for forward compatibility.
//
// Nginx Management Service
type NginxServiceServer interface {
	CreateVirtualHost(context.Context, *CreateVirtualHostRequest) (*CreateVirtualHostResponse, error)
	EnableVirtualHost(context.Context, *EnableVirtualHostRequest) (*EnableVirtualHostResponse, error)
	DisableVirtualHost(context.Context, *DisableVirtualHostRequest) (*DisableVirtualHostResponse, error)
	DeleteVirtualHost(context.Context, *DeleteVirtualHostRequest) (*DeleteVirtualHostResponse, error)
	ListVirtualHosts(context.Context, *ListVirtualHostsRequest) (*ListVirtualHostsResponse, error)
	CreateReverseProxy(context.Context, *CreateReverseProxyRequest) (*CreateReverseProxyResponse, error)
	CreateLoadBalancer(context.Context, *CreateLoadBalancerRequest) (*CreateLoadBalancerResponse, error)
	mustEmbedUnimplementedNginxServiceServer()
}

// UnimplementedNginxServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNginxServiceServer struct{}

func (UnimplementedNginxServiceServer) CreateVirtualHost(context.Context, *CreateVirtualHostRequest) (*CreateVirtualHostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateVirtualHost not implemented")
}
func (UnimplementedNginxServiceServer) EnableVirtualHost(context.Context, *EnableVirtualHostRequest) (*EnableVirtualHostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnableVirtualHost not implemented")
}
func (UnimplementedNginxServiceServer) DisableVirtualHost(context.Context, *DisableVirtualHostRequest) (*DisableVirtualHostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DisableVirtualHost not implemented")
}
func (UnimplementedNginxServiceServer) DeleteVirtualHost(context.Context, *DeleteVirtualHostRequest) (*DeleteVirtualHostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteVirtualHost not implemented")
}
func (UnimplementedNginxServiceServer) ListVirtualHosts(context.Context, *ListVirtualHostsRequest) (*ListVirtualHostsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListVirtualHosts not implemented")
}
func (UnimplementedNginxServiceServer) CreateReverseProxy(context.Context, *CreateReverseProxyRequest) (*CreateReverseProxyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateReverseProxy not implemented")
}
func (UnimplementedNginxServiceServer) CreateLoadBalancer(context.Context, *CreateLoadBalancerRequest) (*CreateLoadBalancerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateLoadBalancer not implemented")
}
func (UnimplementedNginxServiceServer) mustEmbedUnimplementedNginxServiceServer() {}
func (UnimplementedNginxServiceServer) testEmbeddedByValue()                      {}

// UnsafeNginxServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NginxServiceServer will
// result in compilation errors.
type UnsafeNginxServiceServer interface {
	mustEmbedUnimplementedNginxServiceServer()
}

func RegisterNginxServiceServer(s grpc.ServiceRegistrar, srv NginxServiceServer) {
	// If the following call panics, it indicates UnimplementedNginxServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NginxService_ServiceDesc, srv)
}

func _NginxService_CreateVirtualHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVirtualHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NginxServiceServer).CreateVirtualHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NginxService_CreateVirtualHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NginxServiceServer).CreateVirtualHost(ctx, req.(*CreateVirtualHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NginxService_EnableVirtualHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableVirtualHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NginxServiceServer).EnableVirtualHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NginxService_EnableVirtualHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NginxServiceServer).EnableVirtualHost(ctx, req.(*EnableVirtualHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NginxService_DisableVirtualHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableVirtualHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NginxServiceServer).DisableVirtualHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NginxService_DisableVirtualHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NginxServiceServer).DisableVirtualHost(ctx, req.(*DisableVirtualHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NginxService_DeleteVirtualHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVirtualHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NginxServiceServer).DeleteVirtualHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NginxService_DeleteVirtualHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NginxServiceServer).DeleteVirtualHost(ctx, req.(*DeleteVirtualHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NginxService_ListVirtualHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVirtualHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NginxServiceServer).ListVirtualHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NginxService_ListVirtualHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NginxServiceServer).ListVirtualHosts(ctx, req.(*ListVirtualHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NginxService_CreateReverseProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReverseProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NginxServiceServer).CreateReverseProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NginxService_CreateReverseProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NginxServiceServer).CreateReverseProxy(ctx, req.(*CreateReverseProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NginxService_CreateLoadBalancer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLoadBalancerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NginxServiceServer).CreateLoadBalancer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NginxService_CreateLoadBalancer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NginxServiceServer).CreateLoadBalancer(ctx, req.(*CreateLoadBalancerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NginxService_ServiceDesc is the grpc.ServiceDesc for NginxService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NginxService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.services.v1.NginxService",
	HandlerType: (*NginxServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVirtualHost",
			Handler:    _NginxService_CreateVirtualHost_Handler,
		},
		{
			MethodName: "EnableVirtualHost",
			Handler:    _NginxService_EnableVirtualHost_Handler,
		},
		{
			MethodName: "DisableVirtualHost",
			Handler:    _NginxService_DisableVirtualHost_Handler,
		},
		{
			MethodName: "DeleteVirtualHost",
			Handler:    _NginxService_DeleteVirtualHost_Handler,
		},
		{
			MethodName: "ListVirtualHosts",
			Handler:    _NginxService_ListVirtualHosts_Handler,
		},
		{
			MethodName: "CreateReverseProxy",
			Handler:    _NginxService_CreateReverseProxy_Handler,
		},
		{
			MethodName: "CreateLoadBalancer",
			Handler:    _NginxService_CreateLoadBalancer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/service.proto",
}

const (
	SystemdService_CreateService_FullMethodName    = "/mandau.services.v1.SystemdService/CreateService"
	SystemdService_EnableService_FullMethodName    = "/mandau.services.v1.SystemdService/EnableService"
	SystemdService_DisableService_FullMethodName   = "/mandau.services.v1.SystemdService/DisableService"
	SystemdService_StartService_FullMethodName     = "/mandau.services.v1.SystemdService/StartService"
	SystemdService_StopService_FullMethodName      = "/mandau.services.v1.SystemdService/StopService"
	SystemdService_RestartService_FullMethodName   = "/mandau.services.v1.SystemdService/RestartService"
	SystemdService_GetServiceStatus_FullMethodName = "/mandau.services.v1.SystemdService/GetServiceStatus"
	SystemdService_ListServices_FullMethodName     = "/mandau.services.v1.SystemdService/ListServices"
)

// SystemdServiceClient is the client API for SystemdService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Systemd Service Management
type SystemdServiceClient interface {
	CreateService(ctx context.Context, in *CreateServiceRequest, opts ...grpc.CallOption) (*CreateServiceResponse, error)
	EnableService(ctx context.Context, in *EnableServiceRequest, opts ...grpc.CallOption) (*EnableServiceResponse, error)
	DisableService(ctx context.Context, in *DisableServiceRequest, opts ...grpc.CallOption) (*DisableServiceResponse, error)
	StartService(ctx context.Context, in *StartServiceRequest, opts ...grpc.CallOption) (*StartServiceResponse, error)
	StopService(ctx context.Context, in *StopServiceRequest, opts ...grpc.CallOption) (*StopServiceResponse, error)
	RestartService(ctx context.Context, in *RestartServiceRequest, opts ...grpc.CallOption) (*RestartServiceResponse, error)
	GetServiceStatus(ctx context.Context, in *GetServiceStatusRequest, opts ...grpc.CallOption) (*GetServiceStatusResponse, error)
	ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error)
}

type systemdServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSystemdServiceClient(cc grpc.ClientConnInterface) SystemdServiceClient {
	return &systemdServiceClient{cc}
}

func (c *systemdServiceClient) CreateService(ctx context.Context, in *CreateServiceRequest, opts ...grpc.CallOption) (*CreateServiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateServiceResponse)
	err := c.cc.Invoke(ctx, SystemdService_CreateService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemdServiceClient) EnableService(ctx context.Context, in *EnableServiceRequest, opts ...grpc.CallOption) (*EnableServiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableServiceResponse)
	err := c.cc.Invoke(ctx, SystemdService_EnableService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemdServiceClient) DisableService(ctx context.Context, in *DisableServiceRequest, opts ...grpc.CallOption) (*DisableServiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableServiceResponse)
	err := c.cc.Invoke(ctx, SystemdService_DisableService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemdServiceClient) StartService(ctx context.Context, in *StartServiceRequest, opts ...grpc.CallOption) (*StartServiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartServiceResponse)
	err := c.cc.Invoke(ctx, SystemdService_StartService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemdServiceClient) StopService(ctx context.Context, in *StopServiceRequest, opts ...grpc.CallOption) (*StopServiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopServiceResponse)
	err := c.cc.Invoke(ctx, SystemdService_StopService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemdServiceClient) RestartService(ctx context.Context, in *RestartServiceRequest, opts ...grpc.CallOption) (*RestartServiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestartServiceResponse)
	err := c.cc.Invoke(ctx, SystemdService_RestartService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemdServiceClient) GetServiceStatus(ctx context.Context, in *GetServiceStatusRequest, opts ...grpc.CallOption) (*GetServiceStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetServiceStatusResponse)
	err := c.cc.Invoke(ctx, SystemdService_GetServiceStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemdServiceClient) ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListServicesResponse)
	err := c.cc.Invoke(ctx, SystemdService_ListServices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SystemdServiceServer is the server API for SystemdService service.
// All implementations must embed UnimplementedSystemdServiceServer
// for forward compatibility.
//
// Systemd Service Management
type SystemdServiceServer interface {
	CreateService(context.Context, *CreateServiceRequest) (*CreateServiceResponse, error)
	EnableService(context.Context, *EnableServiceRequest) (*EnableServiceResponse, error)
	DisableService(context.Context, *DisableServiceRequest) (*DisableServiceResponse, error)
	StartService(context.Context, *StartServiceRequest) (*StartServiceResponse, error)
	StopService(context.Context, *StopServiceRequest) (*StopServiceResponse, error)
	RestartService(context.Context, *RestartServiceRequest) (*RestartServiceResponse, error)
	GetServiceStatus(context.Context, *GetServiceStatusRequest) (*GetServiceStatusResponse, error)
	ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error)
	mustEmbedUnimplementedSystemdServiceServer()
}

// UnimplementedSystemdServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSystemdServiceServer struct{}

func (UnimplementedSystemdServiceServer) CreateService(context.Context, *CreateServiceRequest) (*CreateServiceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateService not implemented")
}
func (UnimplementedSystemdServiceServer) EnableService(context.Context, *EnableServiceRequest) (*EnableServiceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnableService not implemented")
}
func (UnimplementedSystemdServiceServer) DisableService(context.Context, *DisableServiceRequest) (*DisableServiceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DisableService not implemented")
}
func (UnimplementedSystemdServiceServer) StartService(context.Context, *StartServiceRequest) (*StartServiceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartService not implemented")
}
func (UnimplementedSystemdServiceServer) StopService(context.Context, *StopServiceRequest) (*StopServiceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopService not implemented")
}
func (UnimplementedSystemdServiceServer) RestartService(context.Context, *RestartServiceRequest) (*RestartServiceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestartService not implemented")
}
func (UnimplementedSystemdServiceServer) GetServiceStatus(context.Context, *GetServiceStatusRequest) (*GetServiceStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetServiceStatus not implemented")
}
func (UnimplementedSystemdServiceServer) ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListServices not implemented")
}
func (UnimplementedSystemdServiceServer) mustEmbedUnimplementedSystemdServiceServer() {}
func (UnimplementedSystemdServiceServer) testEmbeddedByValue()                        {}

// UnsafeSystemdServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SystemdServiceServer will
// result in compilation errors.
type UnsafeSystemdServiceServer interface {
	mustEmbedUnimplementedSystemdServiceServer()
}

func RegisterSystemdServiceServer(s grpc.ServiceRegistrar, srv SystemdServiceServer) {
	// If the following call panics, it indicates UnimplementedSystemdServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SystemdService_ServiceDesc, srv)
}

func _SystemdService_CreateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemdServiceServer).CreateService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemdService_CreateService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemdServiceServer).CreateService(ctx, req.(*CreateServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemdService_EnableService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemdServiceServer).EnableService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemdService_EnableService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemdServiceServer).EnableService(ctx, req.(*EnableServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemdService_DisableService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemdServiceServer).DisableService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemdService_DisableService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemdServiceServer).DisableService(ctx, req.(*DisableServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemdService_StartService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemdServiceServer).StartService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemdService_StartService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemdServiceServer).StartService(ctx, req.(*StartServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemdService_StopService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemdServiceServer).StopService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemdService_StopService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemdServiceServer).StopService(ctx, req.(*StopServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemdService_RestartService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemdServiceServer).RestartService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemdService_RestartService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemdServiceServer).RestartService(ctx, req.(*RestartServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemdService_GetServiceStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemdServiceServer).GetServiceStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemdService_GetServiceStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemdServiceServer).GetServiceStatus(ctx, req.(*GetServiceStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemdService_ListServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemdServiceServer).ListServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemdService_ListServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemdServiceServer).ListServices(ctx, req.(*ListServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SystemdService_ServiceDesc is the grpc.ServiceDesc for SystemdService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SystemdService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.services.v1.SystemdService",
	HandlerType: (*SystemdServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateService",
			Handler:    _SystemdService_CreateService_Handler,
		},
		{
			MethodName: "EnableService",
			Handler:    _SystemdService_EnableService_Handler,
		},
		{
			MethodName: "DisableService",
			Handler:    _SystemdService_DisableService_Handler,
		},
		{
			MethodName: "StartService",
			Handler:    _SystemdService_StartService_Handler,
		},
		{
			MethodName: "StopService",
			Handler:    _SystemdService_StopService_Handler,
		},
		{
			MethodName: "RestartService",
			Handler:    _SystemdService_RestartService_Handler,
		},
		{
			MethodName: "GetServiceStatus",
			Handler:    _SystemdService_GetServiceStatus_Handler,
		},
		{
			MethodName: "ListServices",
			Handler:    _SystemdService_ListServices_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/service.proto",
}

const (
	FirewallService_AddRule_FullMethodName    = "/mandau.services.v1.FirewallService/AddRule"
	FirewallService_DeleteRule_FullMethodName = "/mandau.services.v1.FirewallService/DeleteRule"
	FirewallService_ListRules_FullMethodName  = "/mandau.services.v1.FirewallService/ListRules"
	FirewallService_AllowPort_FullMethodName  = "/mandau.services.v1.FirewallService/AllowPort"
	FirewallService_DenyPort_FullMethodName   = "/mandau.services.v1.FirewallService/DenyPort"
	FirewallService_Enable_FullMethodName     = "/mandau.services.v1.FirewallService/Enable"
	FirewallService_Disable_FullMethodName    = "/mandau.services.v1.FirewallService/Disable"
)

// FirewallServiceClient is the client API for FirewallService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Firewall Service
type FirewallServiceClient interface {
	AddRule(ctx context.Context, in *AddFirewallRuleRequest, opts ...grpc.CallOption) (*AddFirewallRuleResponse, error)
	DeleteRule(ctx context.Context, in *DeleteFirewallRuleRequest, opts ...grpc.CallOption) (*DeleteFirewallRuleResponse, error)
	ListRules(ctx context.Context, in *ListFirewallRulesRequest, opts ...grpc.CallOption) (*ListFirewallRulesResponse, error)
	AllowPort(ctx context.Context, in *AllowPortRequest, opts ...grpc.CallOption) (*AllowPortResponse, error)
	DenyPort(ctx context.Context, in *DenyPortRequest, opts ...grpc.CallOption) (*DenyPortResponse, error)
	Enable(ctx context.Context, in *EnableFirewallRequest, opts ...grpc.CallOption) (*EnableFirewallResponse, error)
	Disable(ctx context.Context, in *DisableFirewallRequest, opts ...grpc.CallOption) (*DisableFirewallResponse, error)
}

type firewallServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFirewallServiceClient(cc grpc.ClientConnInterface) FirewallServiceClient {
	return &firewallServiceClient{cc}
}

func (c *firewallServiceClient) AddRule(ctx context.Context, in *AddFirewallRuleRequest, opts ...grpc.CallOption) (*AddFirewallRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddFirewallRuleResponse)
	err := c.cc.Invoke(ctx, FirewallService_AddRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallServiceClient) DeleteRule(ctx context.Context, in *DeleteFirewallRuleRequest, opts ...grpc.CallOption) (*DeleteFirewallRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteFirewallRuleResponse)
	err := c.cc.Invoke(ctx, FirewallService_DeleteRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallServiceClient) ListRules(ctx context.Context, in *ListFirewallRulesRequest, opts ...grpc.CallOption) (*ListFirewallRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFirewallRulesResponse)
	err := c.cc.Invoke(ctx, FirewallService_ListRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallServiceClient) AllowPort(ctx context.Context, in *AllowPortRequest, opts ...grpc.CallOption) (*AllowPortResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllowPortResponse)
	err := c.cc.Invoke(ctx, FirewallService_AllowPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallServiceClient) DenyPort(ctx context.Context, in *DenyPortRequest, opts ...grpc.CallOption) (*DenyPortResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DenyPortResponse)
	err := c.cc.Invoke(ctx, FirewallService_DenyPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallServiceClient) Enable(ctx context.Context, in *EnableFirewallRequest, opts ...grpc.CallOption) (*EnableFirewallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableFirewallResponse)
	err := c.cc.Invoke(ctx, FirewallService_Enable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallServiceClient) Disable(ctx context.Context, in *DisableFirewallRequest, opts ...grpc.CallOption) (*DisableFirewallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableFirewallResponse)
	err := c.cc.Invoke(ctx, FirewallService_Disable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FirewallServiceServer is the server API for FirewallService service.
// All implementations must embed UnimplementedFirewallServiceServer
// for forward compatibility.
//
// Firewall Service
type FirewallServiceServer interface {
	AddRule(context.Context, *AddFirewallRuleRequest) (*AddFirewallRuleResponse, error)
	DeleteRule(context.Context, *DeleteFirewallRuleRequest) (*DeleteFirewallRuleResponse, error)
	ListRules(context.Context, *ListFirewallRulesRequest) (*ListFirewallRulesResponse, error)
	AllowPort(context.Context, *AllowPortRequest) (*AllowPortResponse, error)
	DenyPort(context.Context, *DenyPortRequest) (*DenyPortResponse, error)
	Enable(context.Context, *EnableFirewallRequest) (*EnableFirewallResponse, error)
	Disable(context.Context, *DisableFirewallRequest) (*DisableFirewallResponse, error)
	mustEmbedUnimplementedFirewallServiceServer()
}

// UnimplementedFirewallServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFirewallServiceServer struct{}

func (UnimplementedFirewallServiceServer) AddRule(context.Context, *AddFirewallRuleRequest) (*AddFirewallRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddRule not implemented")
}
func (UnimplementedFirewallServiceServer) DeleteRule(context.Context, *DeleteFirewallRuleRequest) (*DeleteFirewallRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteRule not implemented")
}
func (UnimplementedFirewallServiceServer) ListRules(context.Context, *ListFirewallRulesRequest) (*ListFirewallRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRules not implemented")
}
func (UnimplementedFirewallServiceServer) AllowPort(context.Context, *AllowPortRequest) (*AllowPortResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AllowPort not implemented")
}
func (UnimplementedFirewallServiceServer) DenyPort(context.Context, *DenyPortRequest) (*DenyPortResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DenyPort not implemented")
}
func (UnimplementedFirewallServiceServer) Enable(context.Context, *EnableFirewallRequest) (*EnableFirewallResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Enable not implemented")
}
func (UnimplementedFirewallServiceServer) Disable(context.Context, *DisableFirewallRequest) (*DisableFirewallResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Disable not implemented")
}
func (UnimplementedFirewallServiceServer) mustEmbedUnimplementedFirewallServiceServer() {}
func (UnimplementedFirewallServiceServer) testEmbeddedByValue()                         {}

// UnsafeFirewallServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FirewallServiceServer will
// result in compilation errors.
type UnsafeFirewallServiceServer interface {
	mustEmbedUnimplementedFirewallServiceServer()
}

func RegisterFirewallServiceServer(s grpc.ServiceRegistrar, srv FirewallServiceServer) {
	// If the following call panics, it indicates UnimplementedFirewallServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FirewallService_ServiceDesc, srv)
}

func _FirewallService_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFirewallRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallServiceServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallService_AddRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallServiceServer).AddRule(ctx, req.(*AddFirewallRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallService_DeleteRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFirewallRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallServiceServer).DeleteRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallService_DeleteRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallServiceServer).DeleteRule(ctx, req.(*DeleteFirewallRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallService_ListRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFirewallRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallServiceServer).ListRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallService_ListRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallServiceServer).ListRules(ctx, req.(*ListFirewallRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallService_AllowPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllowPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallServiceServer).AllowPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallService_AllowPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallServiceServer).AllowPort(ctx, req.(*AllowPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallService_DenyPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DenyPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallServiceServer).DenyPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallService_DenyPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallServiceServer).DenyPort(ctx, req.(*DenyPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallService_Enable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableFirewallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallServiceServer).Enable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallService_Enable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallServiceServer).Enable(ctx, req.(*EnableFirewallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallService_Disable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableFirewallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallServiceServer).Disable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallService_Disable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallServiceServer).Disable(ctx, req.(*DisableFirewallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FirewallService_ServiceDesc is the grpc.ServiceDesc for FirewallService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FirewallService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.services.v1.FirewallService",
	HandlerType: (*FirewallServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRule",
			Handler:    _FirewallService_AddRule_Handler,
		},
		{
			MethodName: "DeleteRule",
			Handler:    _FirewallService_DeleteRule_Handler,
		},
		{
			MethodName: "ListRules",
			Handler:    _FirewallService_ListRules_Handler,
		},
		{
			MethodName: "AllowPort",
			Handler:    _FirewallService_AllowPort_Handler,
		},
		{
			MethodName: "DenyPort",
			Handler:    _FirewallService_DenyPort_Handler,
		},
		{
			MethodName: "Enable",
			Handler:    _FirewallService_Enable_Handler,
		},
		{
			MethodName: "Disable",
			Handler:    _FirewallService_Disable_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/service.proto",
}

const (
	ACMEService_ObtainCertificate_FullMethodName = "/mandau.services.v1.ACMEService/ObtainCertificate"
	ACMEService_RenewCertificate_FullMethodName  = "/mandau.services.v1.ACMEService/RenewCertificate"
	ACMEService_RenewAll_FullMethodName          = "/mandau.services.v1.ACMEService/RenewAll"
	ACMEService_RevokeCertificate_FullMethodName = "/mandau.services.v1.ACMEService/RevokeCertificate"
	ACMEService_ListCertificates_FullMethodName  = "/mandau.services.v1.ACMEService/ListCertificates"
)

// ACMEServiceClient is the client API for ACMEService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ACME/SSL Certificate Service
type ACMEServiceClient interface {
	ObtainCertificate(ctx context.Context, in *ObtainCertificateRequest, opts ...grpc.CallOption) (*ObtainCertificateResponse, error)
	RenewCertificate(ctx context.Context, in *RenewCertificateRequest, opts ...grpc.CallOption) (*RenewCertificateResponse, error)
	RenewAll(ctx context.Context, in *RenewAllCertificatesRequest, opts ...grpc.CallOption) (*RenewAllCertificatesResponse, error)
	RevokeCertificate(ctx context.Context, in *RevokeCertificateRequest, opts ...grpc.CallOption) (*RevokeCertificateResponse, error)
	ListCertificates(ctx context.Context, in *ListCertificatesRequest, opts ...grpc.CallOption) (*ListCertificatesResponse, error)
}

type aCMEServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewACMEServiceClient(cc grpc.ClientConnInterface) ACMEServiceClient {
	return &aCMEServiceClient{cc}
}

func (c *aCMEServiceClient) ObtainCertificate(ctx context.Context, in *ObtainCertificateRequest, opts ...grpc.CallOption) (*ObtainCertificateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ObtainCertificateResponse)
	err := c.cc.Invoke(ctx, ACMEService_ObtainCertificate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCMEServiceClient) RenewCertificate(ctx context.Context, in *RenewCertificateRequest, opts ...grpc.CallOption) (*RenewCertificateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenewCertificateResponse)
	err := c.cc.Invoke(ctx, ACMEService_RenewCertificate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCMEServiceClient) RenewAll(ctx context.Context, in *RenewAllCertificatesRequest, opts ...grpc.CallOption) (*RenewAllCertificatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenewAllCertificatesResponse)
	err := c.cc.Invoke(ctx, ACMEService_RenewAll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCMEServiceClient) RevokeCertificate(ctx context.Context, in *RevokeCertificateRequest, opts ...grpc.CallOption) (*RevokeCertificateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeCertificateResponse)
	err := c.cc.Invoke(ctx, ACMEService_RevokeCertificate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCMEServiceClient) ListCertificates(ctx context.Context, in *ListCertificatesRequest, opts ...grpc.CallOption) (*ListCertificatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCertificatesResponse)
	err := c.cc.Invoke(ctx, ACMEService_ListCertificates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ACMEServiceServer is the server API for ACMEService service.
// All implementations must embed UnimplementedACMEServiceServer
// for forward compatibility.
//
// ACME/SSL Certificate Service
type ACMEServiceServer interface {
	ObtainCertificate(context.Context, *ObtainCertificateRequest) (*ObtainCertificateResponse, error)
	RenewCertificate(context.Context, *RenewCertificateRequest) (*RenewCertificateResponse, error)
	RenewAll(context.Context, *RenewAllCertificatesRequest) (*RenewAllCertificatesResponse, error)
	RevokeCertificate(context.Context, *RevokeCertificateRequest) (*RevokeCertificateResponse, error)
	ListCertificates(context.Context, *ListCertificatesRequest) (*ListCertificatesResponse, error)
	mustEmbedUnimplementedACMEServiceServer()
}

// UnimplementedACMEServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedACMEServiceServer struct{}

func (UnimplementedACMEServiceServer) ObtainCertificate(context.Context, *ObtainCertificateRequest) (*ObtainCertificateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ObtainCertificate not implemented")
}
func (UnimplementedACMEServiceServer) RenewCertificate(context.Context, *RenewCertificateRequest) (*RenewCertificateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RenewCertificate not implemented")
}
func (UnimplementedACMEServiceServer) RenewAll(context.Context, *RenewAllCertificatesRequest) (*RenewAllCertificatesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RenewAll not implemented")
}
func (UnimplementedACMEServiceServer) RevokeCertificate(context.Context, *RevokeCertificateRequest) (*RevokeCertificateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeCertificate not implemented")
}
func (UnimplementedACMEServiceServer) ListCertificates(context.Context, *ListCertificatesRequest) (*ListCertificatesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCertificates not implemented")
}
func (UnimplementedACMEServiceServer) mustEmbedUnimplementedACMEServiceServer() {}
func (UnimplementedACMEServiceServer) testEmbeddedByValue()                     {}

// UnsafeACMEServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ACMEServiceServer will
// result in compilation errors.
type UnsafeACMEServiceServer interface {
	mustEmbedUnimplementedACMEServiceServer()
}

func RegisterACMEServiceServer(s grpc.ServiceRegistrar, srv ACMEServiceServer) {
	// If the following call panics, it indicates UnimplementedACMEServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ACMEService_ServiceDesc, srv)
}

func _ACMEService_ObtainCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObtainCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ACMEServiceServer).ObtainCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ACMEService_ObtainCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ACMEServiceServer).ObtainCertificate(ctx, req.(*ObtainCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ACMEService_RenewCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenewCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ACMEServiceServer).RenewCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ACMEService_RenewCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ACMEServiceServer).RenewCertificate(ctx, req.(*RenewCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ACMEService_RenewAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenewAllCertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ACMEServiceServer).RenewAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ACMEService_RenewAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ACMEServiceServer).RenewAll(ctx, req.(*RenewAllCertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ACMEService_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ACMEServiceServer).RevokeCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ACMEService_RevokeCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ACMEServiceServer).RevokeCertificate(ctx, req.(*RevokeCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ACMEService_ListCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ACMEServiceServer).ListCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ACMEService_ListCertificates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ACMEServiceServer).ListCertificates(ctx, req.(*ListCertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ACMEService_ServiceDesc is the grpc.ServiceDesc for ACMEService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ACMEService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.services.v1.ACMEService",
	HandlerType: (*ACMEServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ObtainCertificate",
			Handler:    _ACMEService_ObtainCertificate_Handler,
		},
		{
			MethodName: "RenewCertificate",
			Handler:    _ACMEService_RenewCertificate_Handler,
		},
		{
			MethodName: "RenewAll",
			Handler:    _ACMEService_RenewAll_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _ACMEService_RevokeCertificate_Handler,
		},
		{
			MethodName: "ListCertificates",
			Handler:    _ACMEService_ListCertificates_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/service.proto",
}

const (
	HostEnvironmentService_GetHostInfo_FullMethodName    = "/mandau.services.v1.HostEnvironmentService/GetHostInfo"
	HostEnvironmentService_InstallPackage_FullMethodName = "/mandau.services.v1.HostEnvironmentService/InstallPackage"
	HostEnvironmentService_RemovePackage_FullMethodName  = "/mandau.services.v1.HostEnvironmentService/RemovePackage"
	HostEnvironmentService_UpdatePackages_FullMethodName = "/mandau.services.v1.HostEnvironmentService/UpdatePackages"
	HostEnvironmentService_ListPackages_FullMethodName   = "/mandau.services.v1.HostEnvironmentService/ListPackages"
	HostEnvironmentService_SetSysctl_FullMethodName      = "/mandau.services.v1.HostEnvironmentService/SetSysctl"
	HostEnvironmentService_GetSysctl_FullMethodName      = "/mandau.services.v1.HostEnvironmentService/GetSysctl"
)

// HostEnvironmentServiceClient is the client API for HostEnvironmentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Host Environment Service
type HostEnvironmentServiceClient interface {
	GetHostInfo(ctx context.Context, in *GetHostInfoRequest, opts ...grpc.CallOption) (*GetHostInfoResponse, error)
	InstallPackage(ctx context.Context, in *InstallPackageRequest, opts ...grpc.CallOption) (*InstallPackageResponse, error)
	RemovePackage(ctx context.Context, in *RemovePackageRequest, opts ...grpc.CallOption) (*RemovePackageResponse, error)
	UpdatePackages(ctx context.Context, in *UpdatePackagesRequest, opts ...grpc.CallOption) (*UpdatePackagesResponse, error)
	ListPackages(ctx context.Context, in *ListPackagesRequest, opts ...grpc.CallOption) (*ListPackagesResponse, error)
	SetSysctl(ctx context.Context, in *SetSysctlRequest, opts ...grpc.CallOption) (*SetSysctlResponse, error)
	GetSysctl(ctx context.Context, in *GetSysctlRequest, opts ...grpc.CallOption) (*GetSysctlResponse, error)
}

type hostEnvironmentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHostEnvironmentServiceClient(cc grpc.ClientConnInterface) HostEnvironmentServiceClient {
	return &hostEnvironmentServiceClient{cc}
}

func (c *hostEnvironmentServiceClient) GetHostInfo(ctx context.Context, in *GetHostInfoRequest, opts ...grpc.CallOption) (*GetHostInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHostInfoResponse)
	err := c.cc.Invoke(ctx, HostEnvironmentService_GetHostInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostEnvironmentServiceClient) InstallPackage(ctx context.Context, in *InstallPackageRequest, opts ...grpc.CallOption) (*InstallPackageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InstallPackageResponse)
	err := c.cc.Invoke(ctx, HostEnvironmentService_InstallPackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostEnvironmentServiceClient) RemovePackage(ctx context.Context, in *RemovePackageRequest, opts ...grpc.CallOption) (*RemovePackageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemovePackageResponse)
	err := c.cc.Invoke(ctx, HostEnvironmentService_RemovePackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostEnvironmentServiceClient) UpdatePackages(ctx context.Context, in *UpdatePackagesRequest, opts ...grpc.CallOption) (*UpdatePackagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePackagesResponse)
	err := c.cc.Invoke(ctx, HostEnvironmentService_UpdatePackages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostEnvironmentServiceClient) ListPackages(ctx context.Context, in *ListPackagesRequest, opts ...grpc.CallOption) (*ListPackagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPackagesResponse)
	err := c.cc.Invoke(ctx, HostEnvironmentService_ListPackages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostEnvironmentServiceClient) SetSysctl(ctx context.Context, in *SetSysctlRequest, opts ...grpc.CallOption) (*SetSysctlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetSysctlResponse)
	err := c.cc.Invoke(ctx, HostEnvironmentService_SetSysctl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostEnvironmentServiceClient) GetSysctl(ctx context.Context, in *GetSysctlRequest, opts ...grpc.CallOption) (*GetSysctlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSysctlResponse)
	err := c.cc.Invoke(ctx, HostEnvironmentService_GetSysctl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HostEnvironmentServiceServer is the server API for HostEnvironmentService service.
// All implementations must embed UnimplementedHostEnvironmentServiceServer
// for forward compatibility.
//
// Host Environment Service
type HostEnvironmentServiceServer interface {
	GetHostInfo(context.Context, *GetHostInfoRequest) (*GetHostInfoResponse, error)
	InstallPackage(context.Context, *InstallPackageRequest) (*InstallPackageResponse, error)
	RemovePackage(context.Context, *RemovePackageRequest) (*RemovePackageResponse, error)
	UpdatePackages(context.Context, *UpdatePackagesRequest) (*UpdatePackagesResponse, error)
	ListPackages(context.Context, *ListPackagesRequest) (*ListPackagesResponse, error)
	SetSysctl(context.Context, *SetSysctlRequest) (*SetSysctlResponse, error)
	GetSysctl(context.Context, *GetSysctlRequest) (*GetSysctlResponse, error)
	mustEmbedUnimplementedHostEnvironmentServiceServer()
}

// UnimplementedHostEnvironmentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHostEnvironmentServiceServer struct{}

func (UnimplementedHostEnvironmentServiceServer) GetHostInfo(context.Context, *GetHostInfoRequest) (*GetHostInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHostInfo not implemented")
}
func (UnimplementedHostEnvironmentServiceServer) InstallPackage(context.Context, *InstallPackageRequest) (*InstallPackageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InstallPackage not implemented")
}
func (UnimplementedHostEnvironmentServiceServer) RemovePackage(context.Context, *RemovePackageRequest) (*RemovePackageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemovePackage not implemented")
}
func (UnimplementedHostEnvironmentServiceServer) UpdatePackages(context.Context, *UpdatePackagesRequest) (*UpdatePackagesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePackages not implemented")
}
func (UnimplementedHostEnvironmentServiceServer) ListPackages(context.Context, *ListPackagesRequest) (*ListPackagesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPackages not implemented")
}
func (UnimplementedHostEnvironmentServiceServer) SetSysctl(context.Context, *SetSysctlRequest) (*SetSysctlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetSysctl not implemented")
}
func (UnimplementedHostEnvironmentServiceServer) GetSysctl(context.Context, *GetSysctlRequest) (*GetSysctlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSysctl not implemented")
}
func (UnimplementedHostEnvironmentServiceServer) mustEmbedUnimplementedHostEnvironmentServiceServer() {
}
func (UnimplementedHostEnvironmentServiceServer) testEmbeddedByValue() {}

// UnsafeHostEnvironmentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HostEnvironmentServiceServer will
// result in compilation errors.
type UnsafeHostEnvironmentServiceServer interface {
	mustEmbedUnimplementedHostEnvironmentServiceServer()
}

func RegisterHostEnvironmentServiceServer(s grpc.ServiceRegistrar, srv HostEnvironmentServiceServer) {
	// If the following call panics, it indicates UnimplementedHostEnvironmentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HostEnvironmentService_ServiceDesc, srv)
}

func _HostEnvironmentService_GetHostInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHostInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostEnvironmentServiceServer).GetHostInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostEnvironmentService_GetHostInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostEnvironmentServiceServer).GetHostInfo(ctx, req.(*GetHostInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostEnvironmentService_InstallPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallPackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostEnvironmentServiceServer).InstallPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostEnvironmentService_InstallPackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostEnvironmentServiceServer).InstallPackage(ctx, req.(*InstallPackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostEnvironmentService_RemovePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostEnvironmentServiceServer).RemovePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostEnvironmentService_RemovePackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostEnvironmentServiceServer).RemovePackage(ctx, req.(*RemovePackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostEnvironmentService_UpdatePackages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePackagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostEnvironmentServiceServer).UpdatePackages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostEnvironmentService_UpdatePackages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostEnvironmentServiceServer).UpdatePackages(ctx, req.(*UpdatePackagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostEnvironmentService_ListPackages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPackagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostEnvironmentServiceServer).ListPackages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostEnvironmentService_ListPackages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostEnvironmentServiceServer).ListPackages(ctx, req.(*ListPackagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostEnvironmentService_SetSysctl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSysctlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostEnvironmentServiceServer).SetSysctl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostEnvironmentService_SetSysctl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostEnvironmentServiceServer).SetSysctl(ctx, req.(*SetSysctlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostEnvironmentService_GetSysctl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSysctlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostEnvironmentServiceServer).GetSysctl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostEnvironmentService_GetSysctl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostEnvironmentServiceServer).GetSysctl(ctx, req.(*GetSysctlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HostEnvironmentService_ServiceDesc is the grpc.ServiceDesc for HostEnvironmentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HostEnvironmentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.services.v1.HostEnvironmentService",
	HandlerType: (*HostEnvironmentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHostInfo",
			Handler:    _HostEnvironmentService_GetHostInfo_Handler,
		},
		{
			MethodName: "InstallPackage",
			Handler:    _HostEnvironmentService_InstallPackage_Handler,
		},
		{
			MethodName: "RemovePackage",
			Handler:    _HostEnvironmentService_RemovePackage_Handler,
		},
		{
			MethodName: "UpdatePackages",
			Handler:    _HostEnvironmentService_UpdatePackages_Handler,
		},
		{
			MethodName: "ListPackages",
			Handler:    _HostEnvironmentService_ListPackages_Handler,
		},
		{
			MethodName: "SetSysctl",
			Handler:    _HostEnvironmentService_SetSysctl_Handler,
		},
		{
			MethodName: "GetSysctl",
			Handler:    _HostEnvironmentService_GetSysctl_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/service.proto",
}

const (
	ServiceDeploymentService_DeployWebService_FullMethodName = "/mandau.services.v1.ServiceDeploymentService/DeployWebService"
	ServiceDeploymentService_RemoveWebService_FullMethodName = "/mandau.services.v1.ServiceDeploymentService/RemoveWebService"
)

// ServiceDeploymentServiceClient is the client API for ServiceDeploymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Complete Service Deployment
type ServiceDeploymentServiceClient interface {
	DeployWebService(ctx context.Context, in *DeployWebServiceRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ServiceOperationEvent], error)
	RemoveWebService(ctx context.Context, in *RemoveWebServiceRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ServiceOperationEvent], error)
}

type serviceDeploymentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewServiceDeploymentServiceClient(cc grpc.ClientConnInterface) ServiceDeploymentServiceClient {
	return &serviceDeploymentServiceClient{cc}
}

func (c *serviceDeploymentServiceClient) DeployWebService(ctx context.Context, in *DeployWebServiceRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ServiceOperationEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ServiceDeploymentService_ServiceDesc.Streams[0], ServiceDeploymentService_DeployWebService_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DeployWebServiceRequest, ServiceOperationEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ServiceDeploymentService_DeployWebServiceClient = grpc.ServerStreamingClient[ServiceOperationEvent]

func (c *serviceDeploymentServiceClient) RemoveWebService(ctx context.Context, in *RemoveWebServiceRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ServiceOperationEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ServiceDeploymentService_ServiceDesc.Streams[1], ServiceDeploymentService_RemoveWebService_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RemoveWebServiceRequest, ServiceOperationEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ServiceDeploymentService_RemoveWebServiceClient = grpc.ServerStreamingClient[ServiceOperationEvent]

// ServiceDeploymentServiceServer is the server API for ServiceDeploymentService service.
// All implementations must embed UnimplementedServiceDeploymentServiceServer
// for forward compatibility.
//
// Complete Service Deployment
type ServiceDeploymentServiceServer interface {
	DeployWebService(*DeployWebServiceRequest, grpc.ServerStreamingServer[ServiceOperationEvent]) error
	RemoveWebService(*RemoveWebServiceRequest, grpc.ServerStreamingServer[ServiceOperationEvent]) error
	mustEmbedUnimplementedServiceDeploymentServiceServer()
}

// UnimplementedServiceDeploymentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedServiceDeploymentServiceServer struct{}

func (UnimplementedServiceDeploymentServiceServer) DeployWebService(*DeployWebServiceRequest, grpc.ServerStreamingServer[ServiceOperationEvent]) error {
	return status.Error(codes.Unimplemented, "method DeployWebService not implemented")
}
func (UnimplementedServiceDeploymentServiceServer) RemoveWebService(*RemoveWebServiceRequest, grpc.ServerStreamingServer[ServiceOperationEvent]) error {
	return status.Error(codes.Unimplemented, "method RemoveWebService not implemented")
}
func (UnimplementedServiceDeploymentServiceServer) mustEmbedUnimplementedServiceDeploymentServiceServer() {
}
func (UnimplementedServiceDeploymentServiceServer) testEmbeddedByValue() {}

// UnsafeServiceDeploymentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceDeploymentServiceServer will
// result in compilation errors.
type UnsafeServiceDeploymentServiceServer interface {
	mustEmbedUnimplementedServiceDeploymentServiceServer()
}

func RegisterServiceDeploymentServiceServer(s grpc.ServiceRegistrar, srv ServiceDeploymentServiceServer) {
	// If the following call panics, it indicates UnimplementedServiceDeploymentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ServiceDeploymentService_ServiceDesc, srv)
}

func _ServiceDeploymentService_DeployWebService_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeployWebServiceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServiceDeploymentServiceServer).DeployWebService(m, &grpc.GenericServerStream[DeployWebServiceRequest, ServiceOperationEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ServiceDeploymentService_DeployWebServiceServer = grpc.ServerStreamingServer[ServiceOperationEvent]

func _ServiceDeploymentService_RemoveWebService_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RemoveWebServiceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServiceDeploymentServiceServer).RemoveWebService(m, &grpc.GenericServerStream[RemoveWebServiceRequest, ServiceOperationEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ServiceDeploymentService_RemoveWebServiceServer = grpc.ServerStreamingServer[ServiceOperationEvent]

// ServiceDeploymentService_ServiceDesc is the grpc.ServiceDesc for ServiceDeploymentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServiceDeploymentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.services.v1.ServiceDeploymentService",
	HandlerType: (*ServiceDeploymentServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DeployWebService",
			Handler:       _ServiceDeploymentService_DeployWebService_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RemoveWebService",
			Handler:       _ServiceDeploymentService_RemoveWebService_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/v1/service.proto",
}
