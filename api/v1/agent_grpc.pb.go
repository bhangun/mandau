// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: api/v1/agent.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CoreService_ListAgents_FullMethodName    = "/mandau.agent.v1.CoreService/ListAgents"
	CoreService_RegisterAgent_FullMethodName = "/mandau.agent.v1.CoreService/RegisterAgent"
	CoreService_Heartbeat_FullMethodName     = "/mandau.agent.v1.CoreService/Heartbeat"
)

// CoreServiceClient is the client API for CoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Core Service - Central control plane
type CoreServiceClient interface {
	ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	RegisterAgent(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
}

type coreServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCoreServiceClient(cc grpc.ClientConnInterface) CoreServiceClient {
	return &coreServiceClient{cc}
}

func (c *coreServiceClient) ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, CoreService_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreServiceClient) RegisterAgent(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, CoreService_RegisterAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, CoreService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoreServiceServer is the server API for CoreService service.
// All implementations must embed UnimplementedCoreServiceServer
// for forward compatibility.
//
// Core Service - Central control plane
type CoreServiceServer interface {
	ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error)
	RegisterAgent(context.Context, *RegisterRequest) (*RegisterResponse, error)
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	mustEmbedUnimplementedCoreServiceServer()
}

// UnimplementedCoreServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCoreServiceServer struct{}

func (UnimplementedCoreServiceServer) ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedCoreServiceServer) RegisterAgent(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterAgent not implemented")
}
func (UnimplementedCoreServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedCoreServiceServer) mustEmbedUnimplementedCoreServiceServer() {}
func (UnimplementedCoreServiceServer) testEmbeddedByValue()                     {}

// UnsafeCoreServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CoreServiceServer will
// result in compilation errors.
type UnsafeCoreServiceServer interface {
	mustEmbedUnimplementedCoreServiceServer()
}

func RegisterCoreServiceServer(s grpc.ServiceRegistrar, srv CoreServiceServer) {
	// If the following call panics, it indicates UnimplementedCoreServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CoreService_ServiceDesc, srv)
}

func _CoreService_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServiceServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoreService_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServiceServer).ListAgents(ctx, req.(*ListAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreService_RegisterAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServiceServer).RegisterAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoreService_RegisterAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServiceServer).RegisterAgent(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoreService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CoreService_ServiceDesc is the grpc.ServiceDesc for CoreService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CoreService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.agent.v1.CoreService",
	HandlerType: (*CoreServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAgents",
			Handler:    _CoreService_ListAgents_Handler,
		},
		{
			MethodName: "RegisterAgent",
			Handler:    _CoreService_RegisterAgent_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _CoreService_Heartbeat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/agent.proto",
}

const (
	AgentService_Register_FullMethodName        = "/mandau.agent.v1.AgentService/Register"
	AgentService_Heartbeat_FullMethodName       = "/mandau.agent.v1.AgentService/Heartbeat"
	AgentService_GetCapabilities_FullMethodName = "/mandau.agent.v1.AgentService/GetCapabilities"
	AgentService_GetHealth_FullMethodName       = "/mandau.agent.v1.AgentService/GetHealth"
)

// AgentServiceClient is the client API for AgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Agent Identity & Lifecycle Service
type AgentServiceClient interface {
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	GetCapabilities(ctx context.Context, in *CapabilitiesRequest, opts ...grpc.CallOption) (*CapabilitiesResponse, error)
	GetHealth(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
}

type agentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentServiceClient(cc grpc.ClientConnInterface) AgentServiceClient {
	return &agentServiceClient{cc}
}

func (c *agentServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, AgentService_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, AgentService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetCapabilities(ctx context.Context, in *CapabilitiesRequest, opts ...grpc.CallOption) (*CapabilitiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CapabilitiesResponse)
	err := c.cc.Invoke(ctx, AgentService_GetCapabilities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetHealth(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, AgentService_GetHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServiceServer is the server API for AgentService service.
// All implementations must embed UnimplementedAgentServiceServer
// for forward compatibility.
//
// Agent Identity & Lifecycle Service
type AgentServiceServer interface {
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	GetCapabilities(context.Context, *CapabilitiesRequest) (*CapabilitiesResponse, error)
	GetHealth(context.Context, *HealthRequest) (*HealthResponse, error)
	mustEmbedUnimplementedAgentServiceServer()
}

// UnimplementedAgentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServiceServer struct{}

func (UnimplementedAgentServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedAgentServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedAgentServiceServer) GetCapabilities(context.Context, *CapabilitiesRequest) (*CapabilitiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCapabilities not implemented")
}
func (UnimplementedAgentServiceServer) GetHealth(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHealth not implemented")
}
func (UnimplementedAgentServiceServer) mustEmbedUnimplementedAgentServiceServer() {}
func (UnimplementedAgentServiceServer) testEmbeddedByValue()                      {}

// UnsafeAgentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServiceServer will
// result in compilation errors.
type UnsafeAgentServiceServer interface {
	mustEmbedUnimplementedAgentServiceServer()
}

func RegisterAgentServiceServer(s grpc.ServiceRegistrar, srv AgentServiceServer) {
	// If the following call panics, it indicates UnimplementedAgentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentService_ServiceDesc, srv)
}

func _AgentService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CapabilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetCapabilities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetCapabilities(ctx, req.(*CapabilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetHealth(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentService_ServiceDesc is the grpc.ServiceDesc for AgentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.agent.v1.AgentService",
	HandlerType: (*AgentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _AgentService_Register_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _AgentService_Heartbeat_Handler,
		},
		{
			MethodName: "GetCapabilities",
			Handler:    _AgentService_GetCapabilities_Handler,
		},
		{
			MethodName: "GetHealth",
			Handler:    _AgentService_GetHealth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/agent.proto",
}

const (
	StackService_ListStacks_FullMethodName   = "/mandau.agent.v1.StackService/ListStacks"
	StackService_GetStack_FullMethodName     = "/mandau.agent.v1.StackService/GetStack"
	StackService_ApplyStack_FullMethodName   = "/mandau.agent.v1.StackService/ApplyStack"
	StackService_RemoveStack_FullMethodName  = "/mandau.agent.v1.StackService/RemoveStack"
	StackService_DiffStack_FullMethodName    = "/mandau.agent.v1.StackService/DiffStack"
	StackService_GetStackLogs_FullMethodName = "/mandau.agent.v1.StackService/GetStackLogs"
)

// StackServiceClient is the client API for StackService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Stack Management Service
type StackServiceClient interface {
	ListStacks(ctx context.Context, in *ListStacksRequest, opts ...grpc.CallOption) (*ListStacksResponse, error)
	GetStack(ctx context.Context, in *GetStackRequest, opts ...grpc.CallOption) (*GetStackResponse, error)
	ApplyStack(ctx context.Context, in *ApplyStackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OperationEvent], error)
	RemoveStack(ctx context.Context, in *RemoveStackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OperationEvent], error)
	DiffStack(ctx context.Context, in *DiffStackRequest, opts ...grpc.CallOption) (*DiffStackResponse, error)
	GetStackLogs(ctx context.Context, in *GetStackLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error)
}

type stackServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStackServiceClient(cc grpc.ClientConnInterface) StackServiceClient {
	return &stackServiceClient{cc}
}

func (c *stackServiceClient) ListStacks(ctx context.Context, in *ListStacksRequest, opts ...grpc.CallOption) (*ListStacksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListStacksResponse)
	err := c.cc.Invoke(ctx, StackService_ListStacks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stackServiceClient) GetStack(ctx context.Context, in *GetStackRequest, opts ...grpc.CallOption) (*GetStackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStackResponse)
	err := c.cc.Invoke(ctx, StackService_GetStack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stackServiceClient) ApplyStack(ctx context.Context, in *ApplyStackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OperationEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StackService_ServiceDesc.Streams[0], StackService_ApplyStack_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ApplyStackRequest, OperationEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StackService_ApplyStackClient = grpc.ServerStreamingClient[OperationEvent]

func (c *stackServiceClient) RemoveStack(ctx context.Context, in *RemoveStackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OperationEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StackService_ServiceDesc.Streams[1], StackService_RemoveStack_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RemoveStackRequest, OperationEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StackService_RemoveStackClient = grpc.ServerStreamingClient[OperationEvent]

func (c *stackServiceClient) DiffStack(ctx context.Context, in *DiffStackRequest, opts ...grpc.CallOption) (*DiffStackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DiffStackResponse)
	err := c.cc.Invoke(ctx, StackService_DiffStack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stackServiceClient) GetStackLogs(ctx context.Context, in *GetStackLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StackService_ServiceDesc.Streams[2], StackService_GetStackLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetStackLogsRequest, LogEntry]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StackService_GetStackLogsClient = grpc.ServerStreamingClient[LogEntry]

// StackServiceServer is the server API for StackService service.
// All implementations must embed UnimplementedStackServiceServer
// for forward compatibility.
//
// Stack Management Service
type StackServiceServer interface {
	ListStacks(context.Context, *ListStacksRequest) (*ListStacksResponse, error)
	GetStack(context.Context, *GetStackRequest) (*GetStackResponse, error)
	ApplyStack(*ApplyStackRequest, grpc.ServerStreamingServer[OperationEvent]) error
	RemoveStack(*RemoveStackRequest, grpc.ServerStreamingServer[OperationEvent]) error
	DiffStack(context.Context, *DiffStackRequest) (*DiffStackResponse, error)
	GetStackLogs(*GetStackLogsRequest, grpc.ServerStreamingServer[LogEntry]) error
	mustEmbedUnimplementedStackServiceServer()
}

// UnimplementedStackServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStackServiceServer struct{}

func (UnimplementedStackServiceServer) ListStacks(context.Context, *ListStacksRequest) (*ListStacksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListStacks not implemented")
}
func (UnimplementedStackServiceServer) GetStack(context.Context, *GetStackRequest) (*GetStackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStack not implemented")
}
func (UnimplementedStackServiceServer) ApplyStack(*ApplyStackRequest, grpc.ServerStreamingServer[OperationEvent]) error {
	return status.Error(codes.Unimplemented, "method ApplyStack not implemented")
}
func (UnimplementedStackServiceServer) RemoveStack(*RemoveStackRequest, grpc.ServerStreamingServer[OperationEvent]) error {
	return status.Error(codes.Unimplemented, "method RemoveStack not implemented")
}
func (UnimplementedStackServiceServer) DiffStack(context.Context, *DiffStackRequest) (*DiffStackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DiffStack not implemented")
}
func (UnimplementedStackServiceServer) GetStackLogs(*GetStackLogsRequest, grpc.ServerStreamingServer[LogEntry]) error {
	return status.Error(codes.Unimplemented, "method GetStackLogs not implemented")
}
func (UnimplementedStackServiceServer) mustEmbedUnimplementedStackServiceServer() {}
func (UnimplementedStackServiceServer) testEmbeddedByValue()                      {}

// UnsafeStackServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StackServiceServer will
// result in compilation errors.
type UnsafeStackServiceServer interface {
	mustEmbedUnimplementedStackServiceServer()
}

func RegisterStackServiceServer(s grpc.ServiceRegistrar, srv StackServiceServer) {
	// If the following call panics, it indicates UnimplementedStackServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StackService_ServiceDesc, srv)
}

func _StackService_ListStacks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStacksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StackServiceServer).ListStacks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StackService_ListStacks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StackServiceServer).ListStacks(ctx, req.(*ListStacksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StackService_GetStack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StackServiceServer).GetStack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StackService_GetStack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StackServiceServer).GetStack(ctx, req.(*GetStackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StackService_ApplyStack_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ApplyStackRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StackServiceServer).ApplyStack(m, &grpc.GenericServerStream[ApplyStackRequest, OperationEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StackService_ApplyStackServer = grpc.ServerStreamingServer[OperationEvent]

func _StackService_RemoveStack_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RemoveStackRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StackServiceServer).RemoveStack(m, &grpc.GenericServerStream[RemoveStackRequest, OperationEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StackService_RemoveStackServer = grpc.ServerStreamingServer[OperationEvent]

func _StackService_DiffStack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiffStackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StackServiceServer).DiffStack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StackService_DiffStack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StackServiceServer).DiffStack(ctx, req.(*DiffStackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StackService_GetStackLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetStackLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StackServiceServer).GetStackLogs(m, &grpc.GenericServerStream[GetStackLogsRequest, LogEntry]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StackService_GetStackLogsServer = grpc.ServerStreamingServer[LogEntry]

// StackService_ServiceDesc is the grpc.ServiceDesc for StackService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StackService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.agent.v1.StackService",
	HandlerType: (*StackServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListStacks",
			Handler:    _StackService_ListStacks_Handler,
		},
		{
			MethodName: "GetStack",
			Handler:    _StackService_GetStack_Handler,
		},
		{
			MethodName: "DiffStack",
			Handler:    _StackService_DiffStack_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ApplyStack",
			Handler:       _StackService_ApplyStack_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RemoveStack",
			Handler:       _StackService_RemoveStack_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetStackLogs",
			Handler:       _StackService_GetStackLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/v1/agent.proto",
}

const (
	ContainerService_ListContainers_FullMethodName   = "/mandau.agent.v1.ContainerService/ListContainers"
	ContainerService_InspectContainer_FullMethodName = "/mandau.agent.v1.ContainerService/InspectContainer"
	ContainerService_StreamLogs_FullMethodName       = "/mandau.agent.v1.ContainerService/StreamLogs"
	ContainerService_Exec_FullMethodName             = "/mandau.agent.v1.ContainerService/Exec"
	ContainerService_GetStats_FullMethodName         = "/mandau.agent.v1.ContainerService/GetStats"
	ContainerService_StartContainer_FullMethodName   = "/mandau.agent.v1.ContainerService/StartContainer"
	ContainerService_StopContainer_FullMethodName    = "/mandau.agent.v1.ContainerService/StopContainer"
	ContainerService_RestartContainer_FullMethodName = "/mandau.agent.v1.ContainerService/RestartContainer"
)

// ContainerServiceClient is the client API for ContainerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Container Management Service
type ContainerServiceClient interface {
	ListContainers(ctx context.Context, in *ListContainersRequest, opts ...grpc.CallOption) (*ListContainersResponse, error)
	InspectContainer(ctx context.Context, in *InspectContainerRequest, opts ...grpc.CallOption) (*InspectContainerResponse, error)
	StreamLogs(ctx context.Context, in *StreamLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error)
	Exec(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ExecRequest, ExecResponse], error)
	GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ContainerStats], error)
	StartContainer(ctx context.Context, in *StartContainerRequest, opts ...grpc.CallOption) (*StartContainerResponse, error)
	StopContainer(ctx context.Context, in *StopContainerRequest, opts ...grpc.CallOption) (*StopContainerResponse, error)
	RestartContainer(ctx context.Context, in *RestartContainerRequest, opts ...grpc.CallOption) (*RestartContainerResponse, error)
}

type containerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewContainerServiceClient(cc grpc.ClientConnInterface) ContainerServiceClient {
	return &containerServiceClient{cc}
}

func (c *containerServiceClient) ListContainers(ctx context.Context, in *ListContainersRequest, opts ...grpc.CallOption) (*ListContainersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListContainersResponse)
	err := c.cc.Invoke(ctx, ContainerService_ListContainers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) InspectContainer(ctx context.Context, in *InspectContainerRequest, opts ...grpc.CallOption) (*InspectContainerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InspectContainerResponse)
	err := c.cc.Invoke(ctx, ContainerService_InspectContainer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) StreamLogs(ctx context.Context, in *StreamLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ContainerService_ServiceDesc.Streams[0], ContainerService_StreamLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamLogsRequest, LogEntry]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ContainerService_StreamLogsClient = grpc.ServerStreamingClient[LogEntry]

func (c *containerServiceClient) Exec(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ExecRequest, ExecResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ContainerService_ServiceDesc.Streams[1], ContainerService_Exec_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecRequest, ExecResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ContainerService_ExecClient = grpc.BidiStreamingClient[ExecRequest, ExecResponse]

func (c *containerServiceClient) GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ContainerStats], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ContainerService_ServiceDesc.Streams[2], ContainerService_GetStats_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetStatsRequest, ContainerStats]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ContainerService_GetStatsClient = grpc.ServerStreamingClient[ContainerStats]

func (c *containerServiceClient) StartContainer(ctx context.Context, in *StartContainerRequest, opts ...grpc.CallOption) (*StartContainerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartContainerResponse)
	err := c.cc.Invoke(ctx, ContainerService_StartContainer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) StopContainer(ctx context.Context, in *StopContainerRequest, opts ...grpc.CallOption) (*StopContainerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopContainerResponse)
	err := c.cc.Invoke(ctx, ContainerService_StopContainer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) RestartContainer(ctx context.Context, in *RestartContainerRequest, opts ...grpc.CallOption) (*RestartContainerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestartContainerResponse)
	err := c.cc.Invoke(ctx, ContainerService_RestartContainer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContainerServiceServer is the server API for ContainerService service.
// All implementations must embed UnimplementedContainerServiceServer
// for forward compatibility.
//
// Container Management Service
type ContainerServiceServer interface {
	ListContainers(context.Context, *ListContainersRequest) (*ListContainersResponse, error)
	InspectContainer(context.Context, *InspectContainerRequest) (*InspectContainerResponse, error)
	StreamLogs(*StreamLogsRequest, grpc.ServerStreamingServer[LogEntry]) error
	Exec(grpc.BidiStreamingServer[ExecRequest, ExecResponse]) error
	GetStats(*GetStatsRequest, grpc.ServerStreamingServer[ContainerStats]) error
	StartContainer(context.Context, *StartContainerRequest) (*StartContainerResponse, error)
	StopContainer(context.Context, *StopContainerRequest) (*StopContainerResponse, error)
	RestartContainer(context.Context, *RestartContainerRequest) (*RestartContainerResponse, error)
	mustEmbedUnimplementedContainerServiceServer()
}

// UnimplementedContainerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedContainerServiceServer struct{}

func (UnimplementedContainerServiceServer) ListContainers(context.Context, *ListContainersRequest) (*ListContainersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListContainers not implemented")
}
func (UnimplementedContainerServiceServer) InspectContainer(context.Context, *InspectContainerRequest) (*InspectContainerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InspectContainer not implemented")
}
func (UnimplementedContainerServiceServer) StreamLogs(*StreamLogsRequest, grpc.ServerStreamingServer[LogEntry]) error {
	return status.Error(codes.Unimplemented, "method StreamLogs not implemented")
}
func (UnimplementedContainerServiceServer) Exec(grpc.BidiStreamingServer[ExecRequest, ExecResponse]) error {
	return status.Error(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedContainerServiceServer) GetStats(*GetStatsRequest, grpc.ServerStreamingServer[ContainerStats]) error {
	return status.Error(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedContainerServiceServer) StartContainer(context.Context, *StartContainerRequest) (*StartContainerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartContainer not implemented")
}
func (UnimplementedContainerServiceServer) StopContainer(context.Context, *StopContainerRequest) (*StopContainerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopContainer not implemented")
}
func (UnimplementedContainerServiceServer) RestartContainer(context.Context, *RestartContainerRequest) (*RestartContainerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestartContainer not implemented")
}
func (UnimplementedContainerServiceServer) mustEmbedUnimplementedContainerServiceServer() {}
func (UnimplementedContainerServiceServer) testEmbeddedByValue()                          {}

// UnsafeContainerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContainerServiceServer will
// result in compilation errors.
type UnsafeContainerServiceServer interface {
	mustEmbedUnimplementedContainerServiceServer()
}

func RegisterContainerServiceServer(s grpc.ServiceRegistrar, srv ContainerServiceServer) {
	// If the following call panics, it indicates UnimplementedContainerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ContainerService_ServiceDesc, srv)
}

func _ContainerService_ListContainers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListContainersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).ListContainers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContainerService_ListContainers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).ListContainers(ctx, req.(*ListContainersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_InspectContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectContainerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).InspectContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContainerService_InspectContainer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).InspectContainer(ctx, req.(*InspectContainerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_StreamLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ContainerServiceServer).StreamLogs(m, &grpc.GenericServerStream[StreamLogsRequest, LogEntry]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ContainerService_StreamLogsServer = grpc.ServerStreamingServer[LogEntry]

func _ContainerService_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ContainerServiceServer).Exec(&grpc.GenericServerStream[ExecRequest, ExecResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ContainerService_ExecServer = grpc.BidiStreamingServer[ExecRequest, ExecResponse]

func _ContainerService_GetStats_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetStatsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ContainerServiceServer).GetStats(m, &grpc.GenericServerStream[GetStatsRequest, ContainerStats]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ContainerService_GetStatsServer = grpc.ServerStreamingServer[ContainerStats]

func _ContainerService_StartContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartContainerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).StartContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContainerService_StartContainer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).StartContainer(ctx, req.(*StartContainerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_StopContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopContainerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).StopContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContainerService_StopContainer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).StopContainer(ctx, req.(*StopContainerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_RestartContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartContainerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).RestartContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContainerService_RestartContainer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).RestartContainer(ctx, req.(*RestartContainerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContainerService_ServiceDesc is the grpc.ServiceDesc for ContainerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContainerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.agent.v1.ContainerService",
	HandlerType: (*ContainerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListContainers",
			Handler:    _ContainerService_ListContainers_Handler,
		},
		{
			MethodName: "InspectContainer",
			Handler:    _ContainerService_InspectContainer_Handler,
		},
		{
			MethodName: "StartContainer",
			Handler:    _ContainerService_StartContainer_Handler,
		},
		{
			MethodName: "StopContainer",
			Handler:    _ContainerService_StopContainer_Handler,
		},
		{
			MethodName: "RestartContainer",
			Handler:    _ContainerService_RestartContainer_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamLogs",
			Handler:       _ContainerService_StreamLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Exec",
			Handler:       _ContainerService_Exec_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetStats",
			Handler:       _ContainerService_GetStats_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/v1/agent.proto",
}

const (
	FilesystemService_ListFiles_FullMethodName       = "/mandau.agent.v1.FilesystemService/ListFiles"
	FilesystemService_ReadFile_FullMethodName        = "/mandau.agent.v1.FilesystemService/ReadFile"
	FilesystemService_WriteFile_FullMethodName       = "/mandau.agent.v1.FilesystemService/WriteFile"
	FilesystemService_DeleteFile_FullMethodName      = "/mandau.agent.v1.FilesystemService/DeleteFile"
	FilesystemService_CreateDirectory_FullMethodName = "/mandau.agent.v1.FilesystemService/CreateDirectory"
)

// FilesystemServiceClient is the client API for FilesystemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Filesystem Service
type FilesystemServiceClient interface {
	ListFiles(ctx context.Context, in *ListFilesRequest, opts ...grpc.CallOption) (*ListFilesResponse, error)
	ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileResponse, error)
	WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*WriteFileResponse, error)
	DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error)
	CreateDirectory(ctx context.Context, in *CreateDirectoryRequest, opts ...grpc.CallOption) (*CreateDirectoryResponse, error)
}

type filesystemServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFilesystemServiceClient(cc grpc.ClientConnInterface) FilesystemServiceClient {
	return &filesystemServiceClient{cc}
}

func (c *filesystemServiceClient) ListFiles(ctx context.Context, in *ListFilesRequest, opts ...grpc.CallOption) (*ListFilesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFilesResponse)
	err := c.cc.Invoke(ctx, FilesystemService_ListFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filesystemServiceClient) ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadFileResponse)
	err := c.cc.Invoke(ctx, FilesystemService_ReadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filesystemServiceClient) WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*WriteFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteFileResponse)
	err := c.cc.Invoke(ctx, FilesystemService_WriteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filesystemServiceClient) DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteFileResponse)
	err := c.cc.Invoke(ctx, FilesystemService_DeleteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filesystemServiceClient) CreateDirectory(ctx context.Context, in *CreateDirectoryRequest, opts ...grpc.CallOption) (*CreateDirectoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDirectoryResponse)
	err := c.cc.Invoke(ctx, FilesystemService_CreateDirectory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FilesystemServiceServer is the server API for FilesystemService service.
// All implementations must embed UnimplementedFilesystemServiceServer
// for forward compatibility.
//
// Filesystem Service
type FilesystemServiceServer interface {
	ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error)
	ReadFile(context.Context, *ReadFileRequest) (*ReadFileResponse, error)
	WriteFile(context.Context, *WriteFileRequest) (*WriteFileResponse, error)
	DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error)
	CreateDirectory(context.Context, *CreateDirectoryRequest) (*CreateDirectoryResponse, error)
	mustEmbedUnimplementedFilesystemServiceServer()
}

// UnimplementedFilesystemServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFilesystemServiceServer struct{}

func (UnimplementedFilesystemServiceServer) ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListFiles not implemented")
}
func (UnimplementedFilesystemServiceServer) ReadFile(context.Context, *ReadFileRequest) (*ReadFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadFile not implemented")
}
func (UnimplementedFilesystemServiceServer) WriteFile(context.Context, *WriteFileRequest) (*WriteFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteFile not implemented")
}
func (UnimplementedFilesystemServiceServer) DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteFile not implemented")
}
func (UnimplementedFilesystemServiceServer) CreateDirectory(context.Context, *CreateDirectoryRequest) (*CreateDirectoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateDirectory not implemented")
}
func (UnimplementedFilesystemServiceServer) mustEmbedUnimplementedFilesystemServiceServer() {}
func (UnimplementedFilesystemServiceServer) testEmbeddedByValue()                           {}

// UnsafeFilesystemServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FilesystemServiceServer will
// result in compilation errors.
type UnsafeFilesystemServiceServer interface {
	mustEmbedUnimplementedFilesystemServiceServer()
}

func RegisterFilesystemServiceServer(s grpc.ServiceRegistrar, srv FilesystemServiceServer) {
	// If the following call panics, it indicates UnimplementedFilesystemServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FilesystemService_ServiceDesc, srv)
}

func _FilesystemService_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilesystemServiceServer).ListFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilesystemService_ListFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilesystemServiceServer).ListFiles(ctx, req.(*ListFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilesystemService_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilesystemServiceServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilesystemService_ReadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilesystemServiceServer).ReadFile(ctx, req.(*ReadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilesystemService_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilesystemServiceServer).WriteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilesystemService_WriteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilesystemServiceServer).WriteFile(ctx, req.(*WriteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilesystemService_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilesystemServiceServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilesystemService_DeleteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilesystemServiceServer).DeleteFile(ctx, req.(*DeleteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilesystemService_CreateDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilesystemServiceServer).CreateDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilesystemService_CreateDirectory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilesystemServiceServer).CreateDirectory(ctx, req.(*CreateDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FilesystemService_ServiceDesc is the grpc.ServiceDesc for FilesystemService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FilesystemService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.agent.v1.FilesystemService",
	HandlerType: (*FilesystemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListFiles",
			Handler:    _FilesystemService_ListFiles_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _FilesystemService_ReadFile_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _FilesystemService_WriteFile_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _FilesystemService_DeleteFile_Handler,
		},
		{
			MethodName: "CreateDirectory",
			Handler:    _FilesystemService_CreateDirectory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/agent.proto",
}

const (
	OperationsService_GetOperation_FullMethodName    = "/mandau.agent.v1.OperationsService/GetOperation"
	OperationsService_ListOperations_FullMethodName  = "/mandau.agent.v1.OperationsService/ListOperations"
	OperationsService_CancelOperation_FullMethodName = "/mandau.agent.v1.OperationsService/CancelOperation"
	OperationsService_StreamOperation_FullMethodName = "/mandau.agent.v1.OperationsService/StreamOperation"
)

// OperationsServiceClient is the client API for OperationsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Operations Service
type OperationsServiceClient interface {
	GetOperation(ctx context.Context, in *GetOperationRequest, opts ...grpc.CallOption) (*Operation, error)
	ListOperations(ctx context.Context, in *ListOperationsRequest, opts ...grpc.CallOption) (*ListOperationsResponse, error)
	CancelOperation(ctx context.Context, in *CancelOperationRequest, opts ...grpc.CallOption) (*CancelOperationResponse, error)
	StreamOperation(ctx context.Context, in *StreamOperationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OperationEvent], error)
}

type operationsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOperationsServiceClient(cc grpc.ClientConnInterface) OperationsServiceClient {
	return &operationsServiceClient{cc}
}

func (c *operationsServiceClient) GetOperation(ctx context.Context, in *GetOperationRequest, opts ...grpc.CallOption) (*Operation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Operation)
	err := c.cc.Invoke(ctx, OperationsService_GetOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationsServiceClient) ListOperations(ctx context.Context, in *ListOperationsRequest, opts ...grpc.CallOption) (*ListOperationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOperationsResponse)
	err := c.cc.Invoke(ctx, OperationsService_ListOperations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationsServiceClient) CancelOperation(ctx context.Context, in *CancelOperationRequest, opts ...grpc.CallOption) (*CancelOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelOperationResponse)
	err := c.cc.Invoke(ctx, OperationsService_CancelOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationsServiceClient) StreamOperation(ctx context.Context, in *StreamOperationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OperationEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &OperationsService_ServiceDesc.Streams[0], OperationsService_StreamOperation_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamOperationRequest, OperationEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OperationsService_StreamOperationClient = grpc.ServerStreamingClient[OperationEvent]

// OperationsServiceServer is the server API for OperationsService service.
// All implementations must embed UnimplementedOperationsServiceServer
// for forward compatibility.
//
// Operations Service
type OperationsServiceServer interface {
	GetOperation(context.Context, *GetOperationRequest) (*Operation, error)
	ListOperations(context.Context, *ListOperationsRequest) (*ListOperationsResponse, error)
	CancelOperation(context.Context, *CancelOperationRequest) (*CancelOperationResponse, error)
	StreamOperation(*StreamOperationRequest, grpc.ServerStreamingServer[OperationEvent]) error
	mustEmbedUnimplementedOperationsServiceServer()
}

// UnimplementedOperationsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOperationsServiceServer struct{}

func (UnimplementedOperationsServiceServer) GetOperation(context.Context, *GetOperationRequest) (*Operation, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOperation not implemented")
}
func (UnimplementedOperationsServiceServer) ListOperations(context.Context, *ListOperationsRequest) (*ListOperationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListOperations not implemented")
}
func (UnimplementedOperationsServiceServer) CancelOperation(context.Context, *CancelOperationRequest) (*CancelOperationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelOperation not implemented")
}
func (UnimplementedOperationsServiceServer) StreamOperation(*StreamOperationRequest, grpc.ServerStreamingServer[OperationEvent]) error {
	return status.Error(codes.Unimplemented, "method StreamOperation not implemented")
}
func (UnimplementedOperationsServiceServer) mustEmbedUnimplementedOperationsServiceServer() {}
func (UnimplementedOperationsServiceServer) testEmbeddedByValue()                           {}

// UnsafeOperationsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OperationsServiceServer will
// result in compilation errors.
type UnsafeOperationsServiceServer interface {
	mustEmbedUnimplementedOperationsServiceServer()
}

func RegisterOperationsServiceServer(s grpc.ServiceRegistrar, srv OperationsServiceServer) {
	// If the following call panics, it indicates UnimplementedOperationsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OperationsService_ServiceDesc, srv)
}

func _OperationsService_GetOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationsServiceServer).GetOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperationsService_GetOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationsServiceServer).GetOperation(ctx, req.(*GetOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationsService_ListOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationsServiceServer).ListOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperationsService_ListOperations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationsServiceServer).ListOperations(ctx, req.(*ListOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationsService_CancelOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationsServiceServer).CancelOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperationsService_CancelOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationsServiceServer).CancelOperation(ctx, req.(*CancelOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationsService_StreamOperation_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamOperationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OperationsServiceServer).StreamOperation(m, &grpc.GenericServerStream[StreamOperationRequest, OperationEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OperationsService_StreamOperationServer = grpc.ServerStreamingServer[OperationEvent]

// OperationsService_ServiceDesc is the grpc.ServiceDesc for OperationsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OperationsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mandau.agent.v1.OperationsService",
	HandlerType: (*OperationsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOperation",
			Handler:    _OperationsService_GetOperation_Handler,
		},
		{
			MethodName: "ListOperations",
			Handler:    _OperationsService_ListOperations_Handler,
		},
		{
			MethodName: "CancelOperation",
			Handler:    _OperationsService_CancelOperation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamOperation",
			Handler:       _OperationsService_StreamOperation_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/v1/agent.proto",
}
